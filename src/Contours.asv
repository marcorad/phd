classdef Contours < handle

    properties(Constant)
        hrtol = 0.02; %allowable toleratnce in harmonic ratio
        NHarmonics = 10; %max number of harmonics to detect
        ratios = Features.getRatios(); %harmonic ratios
        ratiosTolUp = Contours.ratios*(1+Features.hrtol); %harmonic ratios positive tolerance
        ratiosTolDown = Contours.ratios/(1+Features.hrtol); %harmonic ratios negative tolerance
        tau = 10; %factor required to be seen as an outlier compared to the denoised spectrum
        M = 15; % MF window size for entropy
        Nmin = 10; %the minimum length in time required for a contour
    end

    properties
        t %the time values of S
        f %the frequency values of S
        S %the tf decomposition
        Smed %the noise estimate of S
        Sden %the denoise spectrum by subtraction
        St %thresholded spectrum according to detected signals
        gmm %the gmm of spectral entropy
        mask %the binary mask of signal detections
        features %features generated by detected contours in S
        info %file info of this segment
        Cdata %the connected contour segments
    end

    methods(Static)
        function r = getRatios()
            t = 1:Features.NHarmonics;
            t = t./t';
            r = t(:);
            r = sort(r(r>1));
            r = unique(r)';
        end
    end

    methods

        function obj = Contours(t, f, S, info, whiten)
            if info == ""
                obj.info.fid = 1;
            else
                obj.info = info;
            end

            obj.S = S;
            obj.t = t;
            obj.f = f;     

            obj.noiseEstimate();

            obj.gmm = SEGMM(Contours.M);
            if whiten
                obj.gmm.detect(S./obj.Smed);
            else
                obj.gmm.detect(S);
            end

            obj.spectrograms();

            obj.Cdata = struct([]);
            obj.features = struct([]);

        end

        function extractContours(obj)
            obj.connect();
            obj.removeShortContours();
            obj.removeHarmonics();
            obj.calculateFeatures();
        end

        function spectrograms(obj)
            obj.mask = obj.gmm.probs >= 0.5;
            obj.St = obj.S .* obj.mask >= obj.Smed*Contours.tau;
            obj.Sden = max(obj.S - obj.Smed, 0);
        end

        function noiseEstimate(obj)
            obj.Smed = median(medfilt1(obj.S, POI.FreqMF, [], 1, "omitnan","truncate"), 2);
            obj.Smed = smoothdata(obj.Smed, "gaussian", POI.SMedSmooth);
        end


        function connect(obj)
            CC = bwconncomp(obj.St, 8);
            Nfft = POI.Nfft;
            fs = POI.fs;
            D = {};
            for i = 1:CC.NumObjects
                idx = CC.PixelIdxList{i};
                [fi, ti] = ind2sub(size(obj.St), idx);
                fmin = min(fi);
                fmax = max(fi);
                tmin = min(ti);
                tmax = max(ti);
                contourmask = zeros( fmax - fmin + 1, tmax - tmin + 1);
                maskamp = zeros( fmax - fmin + 1, tmax - tmin + 1);
                tishift = ti - tmin + 1;
                fishift = fi - fmin + 1;
                contourmask(sub2ind(size(contourmask), fishift, tishift)) = 1;
                maskamp(sub2ind(size(contourmask), fishift, tishift)) = obj.S(idx);
                frange = 0:size(contourmask, 1)-1;
                ampnorm = maskamp./sum(maskamp, 1);
                cenfidx = sum(frange'.*ampnorm, 1);
                cenf = (cenfidx + fmin - 1)/Nfft * fs + obj.f(1);
                p = sum(maskamp, 1);
                bw = sqrt(sum((frange'-cenfidx).^2.*ampnorm, 1))/2;
                cdata.f0 = cenf;
                cdata.P = p;
                cdata.tmin = tmin;
                cdata.tmax = tmax;
                cdata.fmin = fmin;
                cdata.fmax = fmax;
                cdata.bw = bw;
                cdata.idx = idx;
                cdata.cid = i;
                D{i} = cdata;
            end
            obj.Cdata = cell2mat(D);
        end

        function removeHarmonics(obj)
            remove = zeros(1, numel(obj.Cdata)) == 1;
            for i = 1:numel(obj.Cdata)
                ci = obj.Cdata(i);
                for j = 1:numel(obj.Cdata)
                    cj = obj.Cdata(j);
                    sameTime = ci.tmin <= cj.tmax & ci.tmax >= cj.tmin;
                    if sameTime && i ~= j
                        cijtmin = min(ci.tmin, cj.tmin);
                        cijtmax = max(ci.tmax, cj.tmax);
                        ovl = min(ci.tmax, cj.tmax) - max(ci.tmin, cj.tmin) + 1;
                        f0i = NaN(cijtmax - cijtmin + 1, 1);
                        f0j = f0i;
                        f0i((ci.tmin:ci.tmax) - cijtmin + 1) = ci.f0;
                        f0j((cj.tmin:cj.tmax) - cijtmin + 1) = cj.f0;
                        hratio = f0j./f0i;
                        tols = (hratio <= Features.ratiosTolUp & hratio >= Features.ratiosTolDown);
                        withinTol = sum(tols, 1);
                        withinTol = any(withinTol >= ovl*POI.PHarmonic);
                        dur = max(cj.tmax - cj.tmin, ci.tmax - ci.tmin);
                        %                         sameDur = ovl/dur >= (POI.PDuration);
                        %                         higherFreq = sum(hratio > 1, "all") > 0;
                        if withinTol
                            remove(j) = true;
                            if mean(abs(hratio - round(hratio))) < 0.05
                                obj.Cdata(i).NHarmonics = obj.Cdata(i).NHarmonics + 1;
                            else
                                obj.Cdata(i).NContam = obj.Cdata(i).NContam + 1;
                                obj.Cdata(i).Contamcid = [obj.Cdata(i).Contamcid, cj.cid];
                            end
                        else
                            obj.Cdata(i).NContam = obj.Cdata(i).NContam + 1;
                            obj.Cdata(i).Contamcid = [obj.Cdata(i).Contamcid, cj.cid];
                        end
                    end
                end
            end
            obj.Cdata = obj.Cdata(~remove);
        end

        function removeShortContours(obj)
            remove = zeros(1, numel(obj.Cdata)) == 1;
            for i = 1:numel(obj.Cdata)
                c = obj.Cdata(i);
                dur = c.tmax - c.tmin + 1;
                if dur <= Contours.Nmin
                    remove(i) = true;
                end
                obj.Cdata(i).NHarmonics = 0;
                obj.Cdata(i).NContam = 0;
                obj.Cdata(i).Contamcid = [];
            end
            obj.Cdata = obj.Cdata(~remove);
        end


        function calculateFeatures(obj)
            feats = {};
            for i = 1:numel(obj.Cdata)
                cf = ContourFeatures;
                c = obj.Cdata(i);

                cf.bw = c.bw;
                cf.f = c.f0;
                c.p = c.P;
                kbot = find(obj.f - min(c.f0 - c.bw) > 0, 1); %only consider above F0min - BW
                ampmask = ~obj.St(:,c.tmin:c.tmax);
                Sm = obj.Sden(:,c.tmin:c.tmax);
                Sm(ampmask) = 0;
                cf.tp  = sum(Sm(kbot:end, :), 1);
                cf.h = obj.gmm.H;

                Pnoise = max(sum(obj.S(kbot:end, c.tmin:c.tmax), 1) - cf.tp, 0);
                cf.blsnr = mag2db(mean(cf.tp./Pnoise));

                cf.duration = obj.t(c.tmax) - obj.t(c.tmin);
                cf.spectrum = mean(obj.Sden(:, c.tmin:c.tmax), 2);
                cf.sidx = c.tmin;
                cf.eidx = c.tmax;

                cf.cid = i;
                cf.fid = obj.info.fid;

                cf.calculate(obj.t(2) - obj.t(1));
                feats{} = cf;
            end
            obj.feat
        end
    end
end