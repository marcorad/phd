classdef Contours < handle

    properties(Constant)
        hrtol = 0.04; %allowable toleratnce in harmonic ratio
        NHarmonics = 10; %max number of harmonics to detect
        ratios = Contours.getRatios(); %harmonic ratios
        ratiosTolUp = Contours.ratios*(1+Contours.hrtol); %harmonic ratios positive tolerance
        ratiosTolDown = Contours.ratios/(1+Contours.hrtol); %harmonic ratios negative tolerance
        tau = 5; %factor required to be seen as an outlier compared to the noise spectrum
         
        Tmin = 0.5; %the minimum length in time required for a contour
        FreqMF = 7;
        PHarmonic = 0.8;
        PDuration = 0.9;
        NoiseSmooth = 2;
        ProbMul = 1.5;
        BlurStdT = 0.6;
        BlurStdF = 0.2;
        
    end

    properties
        t %the time values of S
        f %the frequency values of S
        S %the tf decomposition
        Smed %the noise estimate of S
        Sden %the denoise spectrum by subtraction
        St %thresholded spectrum according to detected signals
        gmm SEGMM %the gmm of spectral entropy
        mask %the binary mask of signal detections
        features %features generated by detected contours in S
        info %file info of this segment
        Cdata %the connected contour segments
        Scont %the filled in contour map for visualisation
        Nmin %the minimum length of the contour in samples
        M % MF window size for entropy
        Blur = true;
    end

    methods(Static)
        function r = getRatios()
            t = 1:Contours.NHarmonics;
            t = t./t';
            r = t(:);
            r = sort(r(r>1));
            r = unique(r)';
        end

        function Smed = estimateNoise(S)
            Smed = median(medfilt1(S, Contours.FreqMF, [], 1, "omitnan","truncate"), 2);
            Smed = smoothdata(Smed, "gaussian", Contours.NoiseSmooth);
        end

        function Svar = estimateNoiseVar(S)
            Smf = medfilt1(S, Contours.FreqMF, [], 1, "omitnan","truncate");
            Svar = (median(abs(S - Smf), 2)*1.4826).^2;
        end

    end

    methods

        function obj = Contours(fb, S, info)
            if nargin == 2
                obj.info.fid = 1;
            else
                obj.info = info;
            end

            obj.S = S;
            obj.t = fb.getTime(S);
            obj.f = fb.fc;
            obj.Nmin = floor(Contours.Tmin*fb.getSSamplingFreq());
            obj.M = floor(SEGMMCreator.Tmf * fb.getSSamplingFreq())*2 + 1;

            obj.Smed = Contours.estimateNoise(S);
            if obj.Blur
                obj.S = imgaussfilt(obj.S, [Contours.BlurStdF, fb.getSSamplingFreq() * Contours.BlurStdT]);
            end

            obj.Cdata = struct([]);
            obj.features = struct([]);

        end

        function stats = getStatistics(obj)
            stats = obj.gmm.getStatistics();
            stats.info = obj.info;
            stats.noise = obj.Smed;
        end

        function fitGMM(obj, whiten)
            obj.gmm = SEGMM(obj.M);
            if whiten
                obj.gmm.detect(obj.S./obj.Smed);
            else
                obj.gmm.detect(obj.S);
            end
            obj.spectrograms();
        end

        function extractContours(obj)
            obj.connect();
            obj.removeShortContours();
            obj.removeHarmonics();
            obj.calculateFeatures();
            obj.fillContourMap();
        end

        function fillContourMap(obj)
            obj.Scont = zeros(size(obj.S));
            for i = 1:numel(obj.Cdata)
                obj.Scont(obj.Cdata(i).idx) = i;
            end
        end

        function spectrograms(obj)
            obj.mask = obj.gmm.probs >= min(obj.gmm.probs) * Contours.ProbMul;
            obj.St = obj.S .* obj.mask >= obj.Smed*Contours.tau;
            obj.Sden = max(obj.S - obj.Smed, 0);
        end


        function connect(obj)
            CC = bwconncomp(obj.St, 8);
            D = {};
            for i = 1:CC.NumObjects
                idx = CC.PixelIdxList{i};
                [fi, ti] = ind2sub(size(obj.St), idx);
                fmin = min(fi);
                fmax = max(fi);
                tmin = min(ti);
                tmax = max(ti);
                contourmask = zeros( fmax - fmin + 1, tmax - tmin + 1);
                maskamp = zeros( fmax - fmin + 1, tmax - tmin + 1);
                tishift = ti - tmin + 1;
                fishift = fi - fmin + 1;
                contourmask(sub2ind(size(contourmask), fishift, tishift)) = 1;
                maskamp(sub2ind(size(contourmask), fishift, tishift)) = obj.Sden(idx);
                frange = obj.f((1:size(contourmask, 1)) + fmin - 1);
                ampnorm = maskamp./sum(maskamp, 1);
                cenf = sum(frange'.*ampnorm, 1);
                p = sum(maskamp, 1);
                bw = sqrt(sum((frange'-cenf).^2.*ampnorm, 1))/2;
                cdata.f0 = cenf;
                cdata.P = p;
                cdata.tmin = tmin;
                cdata.tmax = tmax;
                cdata.fmin = fmin;
                cdata.fmax = fmax;
                cdata.bw = bw;
                cdata.idx = idx;
                cdata.cid = i;
                D{i} = cdata;
            end
            obj.Cdata = cell2mat(D);
        end

        function removeHarmonics(obj)
            remove = zeros(1, numel(obj.Cdata)) == 1;
            for i = 1:numel(obj.Cdata)
                ci = obj.Cdata(i);
                for j = 1:numel(obj.Cdata)
                    cj = obj.Cdata(j);
                    sameTime = ci.tmin <= cj.tmax & ci.tmax >= cj.tmin;
                    if sameTime && i ~= j
                        cijtmin = min(ci.tmin, cj.tmin);
                        cijtmax = max(ci.tmax, cj.tmax);
                        ovl = min(ci.tmax, cj.tmax) - max(ci.tmin, cj.tmin) + 1;
                        f0i = NaN(cijtmax - cijtmin + 1, 1);
                        f0j = f0i;
                        f0i((ci.tmin:ci.tmax) - cijtmin + 1) = ci.f0;
                        f0j((cj.tmin:cj.tmax) - cijtmin + 1) = cj.f0;
                        hratio = f0j./f0i;
                        tols = (hratio <= Contours.ratiosTolUp & hratio >= Contours.ratiosTolDown);
                        withinTol = sum(tols, 1);
                        withinTol = any(withinTol >= ovl*Contours.PHarmonic);
                        dur = max(cj.tmax - cj.tmin, ci.tmax - ci.tmin);
                        %                         sameDur = ovl/dur >= (POI.PDuration);
                        %                         higherFreq = sum(hratio > 1, "all") > 0;
                        if withinTol
                            remove(j) = true;
                            if mean(abs(hratio - round(hratio))) < 0.05
                                obj.Cdata(i).NHarmonics = obj.Cdata(i).NHarmonics + 1;
                            else
                                obj.Cdata(i).NContam = obj.Cdata(i).NContam + 1;
                                obj.Cdata(i).Contamcid = [obj.Cdata(i).Contamcid, cj.cid];
                            end
                        else
                            obj.Cdata(i).NContam = obj.Cdata(i).NContam + 1;
                            obj.Cdata(i).Contamcid = [obj.Cdata(i).Contamcid, cj.cid];
                        end
                    end
                end
            end
%             obj.Cdata = obj.Cdata(~remove);
        end

        function removeShortContours(obj)
            remove = zeros(1, numel(obj.Cdata)) == 1;
            for i = 1:numel(obj.Cdata)
                c = obj.Cdata(i);
                dur = c.tmax - c.tmin + 1;
                if dur <= obj.Nmin
                    remove(i) = true;
                end
                obj.Cdata(i).NHarmonics = 0;
                obj.Cdata(i).NContam = 0;
                obj.Cdata(i).Contamcid = [];
            end
            obj.Cdata = obj.Cdata(~remove);
        end


        function calculateFeatures(obj)
            if numel(obj.Cdata) ~= 0
                for i = 1:numel(obj.Cdata)
                    cf = ContourFeatures;
                    c = obj.Cdata(i);

                    cf.Bandwidth = c.bw;
                    cf.Frequency = c.f0;
                    cf.Power = c.P;
                    kbot = max(find(obj.f - min(c.f0 - c.bw) >= 0, 1)-1, 1); %only consider above F0min - BW
                    ampmask = ~obj.St(:,c.tmin:c.tmax);
                    Sm = obj.Sden(:,c.tmin:c.tmax);
                    Sm(ampmask) = 0;
                    cf.TotalPower  = sum(Sm(kbot:end, :), 1);
                    cf.Entropy = obj.gmm.H;

                    Pnoise = max(sum(obj.S(kbot:end, c.tmin:c.tmax), 1) - cf.TotalPower, 0);
                    cf.BLSNR = mag2db(mean(cf.TotalPower./Pnoise));

                    cf.Duration = obj.t(c.tmax) - obj.t(c.tmin);
                    cf.Spectrum = mean(obj.Sden(:, c.tmin:c.tmax), 2);
                    cf.StartIndex = c.tmin;
                    cf.EndIndex = c.tmax;

                    cf.ContourID = i;
                    cf.FileID = obj.info.fid;

                    cf.Harmonics = c.NHarmonics;
                    cf.Contamination = c.NContam;
                    cf.ContaminationIDs = {c.Contamcid}; %this must be a cell for table concatenation

                    cf.PowerRatio = cf.Power./cf.TotalPower;

                    cf.calculate(obj.t(2) - obj.t(1));
                    feats(i) = cf;
                end
                obj.features = feats;
            else
                obj.features = [];
            end
        end

        function debugplot(obj, fb)
            figure
            ax1 = subplot(211);
            yyaxis left
            fb.plotS(obj.S./obj.Smed, true);
            yyaxis right
            plot(obj.t, obj.gmm.probs);

            map =  rand(numel(obj.Cdata)*4, 3);
            map = rgb2hsv(map);
            map(:, 3) = min(map(:, 3) + 0.5, 1);
            map = hsv2rgb(map);
            map(1,:) = 0;

            ax2 = subplot(212);
            imagesc(obj.t, obj.f, obj.Scont)
            set(gca, "Ydir", "normal");
            set(gca, "Yscale", "log");
            yticks(round(obj.f(1:8:end),0))
            colormap(ax2, map)
            linkaxes([ax1, ax2], 'x');
            ylim([min(obj.f) max(obj.f)])
            hold on
            for c = obj.Cdata
                tpl = obj.t(c.tmin:c.tmax);
                plot(tpl, c.f0, "w")
                bwu = c.f0 + c.bw;
                bwl = fliplr(c.f0 - c.bw);
                bwpl = [bwu, bwl];
                tbw = [tpl, fliplr(tpl)];
                fill(tbw, bwpl, "red", "FaceAlpha",0.5);
            end
            hold off
        end

        function T = getFeatureTable(obj)
            T = {};
            for idx = 1:numel(obj.features)
                s = obj.features(idx).toStruct();
                T{end + 1} = s;
            end
            if ~isempty(T)
                T = struct2table([T{:}], "AsArray", true);
            end
        end



    end
end