classdef Contours < handle

    properties(Constant)
        hrtol = 0.04; %allowable toleratnce in harmonic ratio
        NHarmonics = 10; %max number of harmonics to detect
        ratios = Contours.getRatios(); %harmonic ratios
        ratiosTolUp = Contours.ratios*(1+Contours.hrtol); %harmonic ratios positive tolerance
        ratiosTolDown = Contours.ratios/(1+Contours.hrtol); %harmonic ratios negative tolerance
        tau = 10; %factor required to be seen as an outlier compared to the denoised spectrum
        M = 15; % MF window size for entropy
        Nmin = 10; %the minimum length in time required for a contour
        FreqMF = 15;
        PHarmonic = 0.8;
        PDuration = 0.9;
        SMedSmooth = 3;
    end

    properties
        t %the time values of S
        f %the frequency values of S
        S %the tf decomposition
        Smed %the noise estimate of S
        Sden %the denoise spectrum by subtraction
        St %thresholded spectrum according to detected signals
        gmm %the gmm of spectral entropy
        mask %the binary mask of signal detections
        features %features generated by detected contours in S
        info %file info of this segment
        Cdata %the connected contour segments
        Scont %the filled in contour map for visualisation
    end

    methods(Static)
        function r = getRatios()
            t = 1:Contours.NHarmonics;
            t = t./t';
            r = t(:);
            r = sort(r(r>1));
            r = unique(r)';
        end
    end

    methods

        function obj = Contours(fb, S, info)
            if nargin == 2
                obj.info.fid = 1;
            else
                obj.info = info;
            end

            obj.S = S;
            obj.t = fb.getTime(S);
            obj.f = fb.fc;

            obj.noiseEstimate();

            obj.Cdata = struct([]);
            obj.features = struct([]);

        end

        function stats = getStatistics(obj)
            stats = obj.gmm.getStatistics();
            stats.info = obj.info;
            stats.noise = obj.Smed;
        end

        function fitGMM(obj, whiten)
            obj.gmm = SEGMM(Contours.M);
            if whiten
                obj.gmm.detect(obj.S./obj.Smed);
            else
                obj.gmm.detect(obj.S);
            end
            obj.spectrograms();
        end

        function extractContours(obj)
            obj.connect();
            obj.removeShortContours();
            obj.removeHarmonics();
            obj.calculateFeatures();
            obj.fillContourMap();
        end

        function fillContourMap(obj)
            obj.Scont = zeros(size(obj.S));
            for i = 1:numel(obj.Cdata)
                obj.Scont(obj.Cdata(i).idx) = i;
            end
        end

        function spectrograms(obj)
            obj.mask = obj.gmm.probs >= 0.5;
            obj.St = obj.S .* obj.mask >= obj.Smed*Contours.tau;
            obj.Sden = max(obj.S - obj.Smed, 0);
        end

        function noiseEstimate(obj)
            obj.Smed = median(medfilt1(obj.S, Contours.FreqMF, [], 1, "omitnan","truncate"), 2);
            obj.Smed = smoothdata(obj.Smed, "gaussian", Contours.SMedSmooth);
        end


        function connect(obj)
            CC = bwconncomp(obj.St, 8);
            D = {};
            for i = 1:CC.NumObjects
                idx = CC.PixelIdxList{i};
                [fi, ti] = ind2sub(size(obj.St), idx);
                fmin = min(fi);
                fmax = max(fi);
                tmin = min(ti);
                tmax = max(ti);
                contourmask = zeros( fmax - fmin + 1, tmax - tmin + 1);
                maskamp = zeros( fmax - fmin + 1, tmax - tmin + 1);
                tishift = ti - tmin + 1;
                fishift = fi - fmin + 1;
                contourmask(sub2ind(size(contourmask), fishift, tishift)) = 1;
                maskamp(sub2ind(size(contourmask), fishift, tishift)) = obj.S(idx);
                frange = obj.f((1:size(contourmask, 1)) + fmin - 1);
                ampnorm = maskamp./sum(maskamp, 1);
                cenf = sum(frange'.*ampnorm, 1);
                p = sum(maskamp, 1);
                bw = sqrt(sum((frange'-cenf).^2.*ampnorm, 1))/2;
                cdata.f0 = cenf;
                cdata.P = p;
                cdata.tmin = tmin;
                cdata.tmax = tmax;
                cdata.fmin = fmin;
                cdata.fmax = fmax;
                cdata.bw = bw;
                cdata.idx = idx;
                cdata.cid = i;
                D{i} = cdata;
            end
            obj.Cdata = cell2mat(D);
        end

        function removeHarmonics(obj)
            remove = zeros(1, numel(obj.Cdata)) == 1;
            for i = 1:numel(obj.Cdata)
                ci = obj.Cdata(i);
                for j = 1:numel(obj.Cdata)
                    cj = obj.Cdata(j);
                    sameTime = ci.tmin <= cj.tmax & ci.tmax >= cj.tmin;
                    if sameTime && i ~= j
                        cijtmin = min(ci.tmin, cj.tmin);
                        cijtmax = max(ci.tmax, cj.tmax);
                        ovl = min(ci.tmax, cj.tmax) - max(ci.tmin, cj.tmin) + 1;
                        f0i = NaN(cijtmax - cijtmin + 1, 1);
                        f0j = f0i;
                        f0i((ci.tmin:ci.tmax) - cijtmin + 1) = ci.f0;
                        f0j((cj.tmin:cj.tmax) - cijtmin + 1) = cj.f0;
                        hratio = f0j./f0i;
                        tols = (hratio <= Contours.ratiosTolUp & hratio >= Contours.ratiosTolDown);
                        withinTol = sum(tols, 1);
                        withinTol = any(withinTol >= ovl*Contours.PHarmonic);
                        dur = max(cj.tmax - cj.tmin, ci.tmax - ci.tmin);
                        %                         sameDur = ovl/dur >= (POI.PDuration);
                        %                         higherFreq = sum(hratio > 1, "all") > 0;
                        if withinTol
                            remove(j) = true;
                            if mean(abs(hratio - round(hratio))) < 0.05
                                obj.Cdata(i).NHarmonics = obj.Cdata(i).NHarmonics + 1;
                            else
                                obj.Cdata(i).NContam = obj.Cdata(i).NContam + 1;
                                obj.Cdata(i).Contamcid = [obj.Cdata(i).Contamcid, cj.cid];
                            end
                        else
                            obj.Cdata(i).NContam = obj.Cdata(i).NContam + 1;
                            obj.Cdata(i).Contamcid = [obj.Cdata(i).Contamcid, cj.cid];
                        end
                    end
                end
            end
            obj.Cdata = obj.Cdata(~remove);
        end

        function removeShortContours(obj)
            remove = zeros(1, numel(obj.Cdata)) == 1;
            for i = 1:numel(obj.Cdata)
                c = obj.Cdata(i);
                dur = c.tmax - c.tmin + 1;
                if dur <= Contours.Nmin
                    remove(i) = true;
                end
                obj.Cdata(i).NHarmonics = 0;
                obj.Cdata(i).NContam = 0;
                obj.Cdata(i).Contamcid = [];
            end
            obj.Cdata = obj.Cdata(~remove);
        end


        function calculateFeatures(obj)
            if numel(obj.Cdata) ~= 0
                for i = 1:numel(obj.Cdata)
                    cf = ContourFeatures;
                    c = obj.Cdata(i);

                    cf.bw = c.bw;
                    cf.f = c.f0;
                    cf.p = c.P;
                    kbot = find(obj.f - min(c.f0 - c.bw) > 0, 1); %only consider above F0min - BW
                    ampmask = ~obj.St(:,c.tmin:c.tmax);
                    Sm = obj.Sden(:,c.tmin:c.tmax);
                    Sm(ampmask) = 0;
                    cf.tp  = sum(Sm(kbot:end, :), 1);
                    cf.h = obj.gmm.H;

                    Pnoise = max(sum(obj.S(kbot:end, c.tmin:c.tmax), 1) - cf.tp, 0);
                    cf.blsnr = mag2db(mean(cf.tp./Pnoise));

                    cf.duration = obj.t(c.tmax) - obj.t(c.tmin);
                    cf.spectrum = mean(obj.Sden(:, c.tmin:c.tmax), 2);
                    cf.sidx = c.tmin;
                    cf.eidx = c.tmax;

                    cf.cid = i;
                    cf.fid = obj.info.fid;

                    cf.harm = c.NHarmonics;
                    cf.ncontam = c.NContam;
                    cf.contamids = c.Contamcid;

                    cf.pr = cf.p./cf.tp;

                    cf.calculate(obj.t(2) - obj.t(1));
                    feats(i) = cf;
                end
                obj.features = feats;
            else
                obj.features = [];
            end
        end

        function debugplot(obj, fb)
            figure
            ax1 = subplot(211);
            fb.plotS(obj.S, true)

            map =  rand(numel(obj.Cdata)*4, 3);
            map = rgb2hsv(map);
            map(:, 3) = min(map(:, 3) + 0.5, 1);
            map = hsv2rgb(map);
            map(1,:) = 0;

            ax2 = subplot(212);
            imagesc(obj.t, obj.f, obj.Scont)
            set(gca, "Ydir", "normal");
            set(gca, "Yscale", "log");
            yticks(round(obj.f(1:8:end),0))
            colormap(ax2, map)
            linkaxes([ax1, ax2]);
            ylim([min(obj.f) max(obj.f)])
            hold on
            for c = obj.Cdata
                tpl = obj.t(c.tmin:c.tmax);
                plot(tpl, c.f0, "w")
                bwu = c.f0 + c.bw;
                bwl = fliplr(c.f0 - c.bw);
                bwpl = [bwu, bwl];
                tbw = [tpl, fliplr(tpl)];
                fill(tbw, bwpl, "red", "FaceAlpha",0.5);
            end
            hold off
        end



    end
end